<!DOCTYPE html>
<HTML>
	<HEAD>
		<TITLE>Design And Analysis Of Algorithms</TITLE>
	</HEAD>
		<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {
  box-sizing: border-box;
}

body {
  font-family: Arial, Helvetica, sans-serif;
}

header {
  background-color: #666;
  padding: 20px;
  text-align: center;
  font-size: 35px;
  color: white;
  height: 300px;
}

nav {
  float: left;
  width: 35%;
  height: 1700px; 
  background: #ccc;
  font-size: 40px;
  padding: 20px;
}

nav ul {
  list-style-type: none;
  padding: 0;
}

article {
  float: left;
  padding: 20px;
  width: 65%;
  background-color: #f1f1f1;
  height: 1700px; 
}

section:after {
  content: "";
  display: table;
  clear: both;
}

footer {
  background-color: black;
  padding: 30px;
  text-align: center;
  color: black;
}

@media (max-width: 600px) {
  nav, article {
    width: 100%;
    height: auto;
  }
}
</style>
</head>
<body>

<header>
  <IMG SRC="C:\Users\DELL\OneDrive\Desktop\DAA PROJECT\algoDesign.jpg" ALIGN="LEFT" HEIGHT="250" WIDTH="400">
			<IMG SRC="C:\Users\DELL\OneDrive\Desktop\DAA PROJECT\algoDesign.jpg" ALIGN="RIGHT" HEIGHT="250" WIDTH="400">
			<BR><br>
			<CENTER>	<B><FONT SIZE="32">Design And Analysis Of Algorithm</FONT></B>	</CENTER>
			<BR><BR><BR><BR>
</header>

<section>
  <nav>
    <ul>Unit-wise description of topics-
      <li><a href="file:///C:/Users/DELL/OneDrive/Desktop/DAA%20PROJECT/F1.html">Unit-1</a></li>
      <li><a href="file:///C:/Users/DELL/OneDrive/Desktop/DAA%20PROJECT/F2.html">Unit-2</a></li>
      <li><a href="file:///C:/Users/DELL/OneDrive/Desktop/DAA%20PROJECT/F3.html">Unit-3</a></li>
	  <li><a href="file:///C:/Users/DELL/OneDrive/Desktop/DAA%20PROJECT/F4.html">Unit-4</a></li>
	  <li><a href="file:///C:/Users/DELL/OneDrive/Desktop/DAA%20PROJECT/F5.html">Unit-5</a></li>
    </ul>
	<img src="C:\Users\DELL\OneDrive\Desktop\DAA PROJECT\daa.png" height="1200px" width="530px">
  </nav>
  
  <article>
  <div style="text-align: right;">
			<INPUT ID="SEARCHBAR" NAME="SEARCH" TYPE="TEXT" PLACEHOLDER="Search Topic" ONKEYUP="search_topic()">
			</DIV>	
    <h1>Design and Analysis of Algorithms</h1>
    <p>Introduction to fundamental techniques for designing and analyzing algorithms,
	 including asymptotic analysis; divide-and-conquer algorithms and recurrences; greedy algorithms;
	  data structures; dynamic programming; graph algorithms; and randomized algorithms.</p>
	 <p>Why study Algorithm?</p>
 <p>  As the speed of processor increases, performance is frequently said to be less central than other software quality characteristics
   (e.g. security, extensibility, reusability etc.). However, large problem sizes are commonplace in the area of computational science,
   which makes performance a very important factor. This is because longer computation time, to name a few mean slower results,
   less through research and higher cost of computation (if buying CPU Hours from an external party). The study of Algorithm,
   therefore, gives us a language to express performance as a function of problem size.</p>
   <p>What is an algorithm?</p>
   <p>A finite set of instruction that specifies a sequence of operation is to be carried out in order 
   to solve a specific problem or class of problems is called an Algorithm.</p>
   <p>An algorithm must have the following properties:</p>
   <p><ul><li>Correctness: It should produce the output according to the requirement of the algorithm
<li>Finiteness: Algorithm must complete after a finite number of instructions have been executed.
<li>An Absence of Ambiguity: Each step must be defined, having only one interpretation.
<li>Definition of Sequence: Each step must have a unique defined preceding and succeeding step. The first step and the last step must be noted.
<li>Input/output: Number and classification of needed inputs and results must be stated.
<li>Feasibility: It must be feasible to execute each instruction.
<li>Flexibility: It should also be possible to make changes in the algorithm without putting so much effort on it.
<li>Efficient: Efficiency is always measured in terms of time and space requires implementing the algorithm, so the algorithm uses a little running time and memory space as possible within the limits of acceptable development time.
<li>Independent: An algorithm should focus on what are inputs, outputs and how to derive output without knowing the language it is defined. Therefore, we can say that the algorithm is independent of language.</ul></p>
	<p><ol>Need of Algorithm
<li> To understand the basic idea of the problem.
<li> To find an approach to solve the problem.
<li> To improve the efficiency of existing techniques.
<li> To understand the basic principles of designing the algorithms.
<li> To compare the performance of the algorithm with respect to other techniques.
<li> It is the best method of description without describing the implementation detail.
<li> The Algorithm gives a clear description of requirements and goal of the problem to the designer.
<li> A good design can produce a good solution.
<li> To understand the flow of the problem.
<li> To measure the behavior (or performance) of the methods in all cases (best cases, worst cases, average cases)
<li> With the help of an algorithm, we can also identify the resources (memory, input-output) cycles required by the algorithm.
<li> With the help of algorithm, we convert art into a science.
<li> To understand the principle of designing.
<li> We can measure and analyze the complexity (time and space) of the problems concerning input size without implementing and running it; it will reduce the cost of design.</ol></p> 
 <pre >Complexity of Algorithm-
It is very convenient to classify algorithm based on the relative amount of time or relative amount of space they 
required and specify the growth of time/space requirement as a function of input size.

1.Time Complexity: Running time of a program as a function of the size of the input.
2.Space Complexity: Some forms of analysis could be done based on how much space an algorithm needs to complete its 
task. This space complexity analysis was critical in the early days of computing when storage space on the computer
was limited. When considering this algorithm are divided into those that need extra space to do their work and
those that work in place.
But now a day's problem of space rarely occurs because space on the computer (internal or external) is enough.

Broadly, we achieve the following types of analysis -


->Worst-case: f (n) defined by the maximum number of steps taken on any instance of size n.
->Best-case: f (n) defined by the minimum number of steps taken on any instance of size n.
->Average case: f (n) defined by the average number of steps taken on any instance of size n.
 </pre>
 <p><ol>Algorithm Design Techniques-<br>
The following is a list of several popular design approaches:

<li> Divide and Conquer Approach: It is a top-down approach. The algorithms which follow the divide & conquer techniques involve three steps:

Divide the original problem into a set of subproblems.
Solve every subproblem individually, recursively.
Combine the solution of the subproblems (top level) into a solution of the whole original problem.
<li> Greedy Technique: Greedy method is used to solve the optimization problem. An optimization problem is one in which we are given a set of input values, which are required either to be maximized or minimized (known as objective), i.e. some constraints or conditions.


Greedy Algorithm always makes the choice (greedy criteria) looks best at the moment, to optimize a given objective.
The greedy algorithm doesn't always guarantee the optimal solution however it generally produces a solution that is very close in value to the optimal.
<li> Dynamic Programming: Dynamic Programming is a bottom-up approach we solve all possible small problems and then combine them to obtain solutions for bigger problems.
This is particularly helpful when the number of copying subproblems is exponentially large. Dynamic Programming is frequently related to Optimization Problems.
<li> Branch and Bound: In Branch & Bound algorithm a given subproblem, which cannot be bounded, has to be divided into at least two new restricted subproblems. Branch and Bound algorithm are methods for global optimization in non-convex problems. Branch and Bound algorithms can be slow, however in the worst case they require effort that grows exponentially with problem size, but in some cases we are lucky, and the method coverage with much less effort.
<li> Randomized Algorithms: A randomized algorithm is defined as an algorithm that is allowed to access a source of independent, unbiased random bits, and it is then allowed to use these random bits to influence its computation.
<li> Backtracking Algorithm: Backtracking Algorithm tries each possibility until they find the right one. It is a depth-first search of the set of possible solution. During the search, if an alternative doesn't work, then backtrack to the choice point, the place which presented different alternatives, and tries the next alternative.
<li> Randomized Algorithm: A randomized algorithm uses a random number at least once during the computation make a decision.
 </ol></p>
 
  </article>
</section>

<footer>
  
</footer>

</body>
</html>
